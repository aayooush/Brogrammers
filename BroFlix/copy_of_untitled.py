# -*- coding: utf-8 -*-
"""Copy of Untitled.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kkK4-RCNwpc2vfqHqQiRLKenmWzKUvGt
"""



from google.colab import drive
drive.mount('/content/drive')

import os
import pandas as pd
import numpy as np

data_path = '/content/drive/My Drive/Brogrammers/data'

ratings = pd.read_csv(os.path.join(data_path, 'ratings.csv'))
movies = pd.read_csv(os.path.join(data_path, 'movies.csv'))
genome_scores = pd.read_csv(os.path.join(data_path, 'genome-scores.csv'))
genome_tags = pd.read_csv(os.path.join(data_path, 'genome-tags.csv'))
# ratings.head()

# genome_tags.head()


# movieProperties.head()
# movieNormalizedNumRatings.head()
movieProperties = ratings.groupby('movieId').agg({'rating': [np.size, np.mean]})
movieNumRatings = pd.DataFrame(movieProperties['rating']['size'])
movieNormalizedNumRatings = movieNumRatings.apply(lambda x: (x - np.min(x)) / (np.max(x) - np.min(x)))
g = list(movies['genres'])
g = [x.split('|') for x in g]
flat_list = []
for sublist in g:
    for item in sublist:
        flat_list.append(item)
genre_list = sorted(set(flat_list))
movieDict = {}
for m in movies.values:
    try:
        movieID = int(m[0])
        name = m[1]
        genres = m[2].split("|")
        g = [1 if i in genres else 0 for i in genre_list]
        movieDict[movieID] = (name, np.array(list(g)), movieNormalizedNumRatings.loc[movieID].get('size'), movieProperties.loc[movieID].rating.get('mean'))
    except:
        pass

def ComputeDistance(a, b):
    genresA = a[1]
    genresB = b[1]
    genreDistance = spatial.distance.cosine(genresA, genresB)
    popularityA = a[2]
    popularityB = b[2]
    popularityDistance = abs(popularityA - popularityB)
    return genreDistance + popularityDistance

ComputeDistance(movieDict[1], movieDict[4])

import operator

def getNeighbors(movieID, K):
    distances = []
    for movie in movieDict:
        if (movie != movieID):
            dist = ComputeDistance(movieDict[movieID], movieDict[movie])
            distances.append((movie, dist))
    distances.sort(key=operator.itemgetter(1))
    neighbors = []
    for x in range(K):
        neighbors.append(distances[x][0])
    return neighbors

K = 10
avgRating = 0

# print(movieDict[1], '\n')
def mmRec(x):
    neighbors = getNeighbors(x, K)
    for neighbor in neighbors:
        avgRating += movieDict[neighbor][3]
        print (movieDict[neighbor][0] + " " + str(movieDict[neighbor][3]))

# avgRating /= K

avgRating

from google.colab import files
files.download('')

"""USER GENRE"""
def userGen(user):
    ratingThresh = np.percentile(ratings[ratings.userId == user]['rating'].values,90)
    moreRate = ratings[(ratings.userId == user) & (ratings.rating >= ratingThresh)]

    def f1(x):
        genomeThresh = np.percentile(genome_scores[genome_scores.movieId == x]['relevance'].values,99)
        print(genomeThresh)
        print(genome_scores[genome_scores.movieId == x])
        moreRelevance = genome_scores[(genome_scores.movieId == x) & (genome_scores.relevance >= genomeThresh)]
        return moreRelevance['tagId']

    def ltags(x):
        k = f1(x['movieId'][x.index[0]])
        if len(k) != 1 :
            i = 1
            while(len(k)>=10 and i < len(x.index)):
                k_prev = k
                k = pd.merge(k, f1(x['movieId'][x.index[i]]), how='inner', on=['tagId'])
                if len(k) == 0:
                    k = k_prev
                i = i+1
        return pd.DataFrame(k,columns=['tagId'])

    tagList = ltags(moreRate)
    tagList

    def f2(x):
        genomeThresh = np.percentile(genome_scores[genome_scores.tagId == x]['relevance'].values,99.9)
        print(genomeThresh)
        print(genome_scores[genome_scores.tagId == x])
        moreRelevance = genome_scores[(genome_scores.tagId == x) & (genome_scores.relevance >= genomeThresh)]

        return moreRelevance['movieId']

    def lmov(x):
        k = f2(x['tagId'][x.index[0]])
        if len(k) != 1 :
            i = 1
            while(len(k)>=10 and i < len(x.index)):
                k_prev = k
                k = pd.merge(k, f2(x['tagId'][x.index[i]]), how='inner', on=['movieId'])
                if len(k) == 0:
                    k = k_prev
                i = i+1
        return pd.DataFrame(k)

    movieList = lmov(tagList)

    def genreSelect(x):
        k = []
        for i in x.values:
            # print(movies[movies.movieId == i[0]]['genres'].values[0])
            k.append(movies[movies.movieId == i[0]]['genres'].values[0].split('|'))
        flat_list = []
        for sublist in k:
            for item in sublist:
                flat_list.append(item)
        genList = []
        m1 = max(set(flat_list), key=flat_list.count)
        genList.append(m1)
        m2 = max(set(list(filter(lambda a: a != m1, flat_list))), key=flat_list.count)
        genList.append(m2)
        
    FinalAns = []
    
    FinalAns.append(genreSelect(movieList))
    

genome_scores.head()

ratings.head()

gr = genome_scores.groupby(by='movieId')
movieIdList = set(genome_scores['movieId'])

maxRelevance = pd.DataFrame(columns=['movieId', 'tagId', 'relevance'])

for i in movieIdList:
    # print(genome_scores[(genome_scores.relevance == max(gr.get_group(i)['relevance'])) & (genome_scores.movieId == i)])
    maxRelevance.loc[len(maxRelevance)] = (genome_scores[(genome_scores.relevance == max(gr.get_group(i)['relevance'])) & (genome_scores.movieId == i)]).values[0]

print(len(maxRelevance))

print(len(movieIdList))



maxRelevance

# userlist = ratings.groupby(by='userId')
# userIdList = set(ratings['userId'])

# maxRating = []
# for i in userIdList:
#     maxRating.append(genome_scores[(genome_scores.relevance == max(gr.get_group(i)['relevance'])) & (genome_scores.movieId == i)].values)
# print(len(maxRelevance))

# print(len(movieIdList))

final = {}
for i in range(len(ratings)):
    movie = ratings.iloc[i, 1]
    user = ratings.iloc[i, 0]
    r = ratings.iloc[i, 2]
    tag = maxRelevance[maxRelevance.movieId == movie]['tagId']

    try:
        final[user] += tag
    except:
        final[user] = tag

final

len(ratings)

